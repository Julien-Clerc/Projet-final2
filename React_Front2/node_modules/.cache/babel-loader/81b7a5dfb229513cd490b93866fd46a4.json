{"ast":null,"code":"import { WebGLRenderTarget, LinearFilter, Scene, Camera, BufferGeometry, BufferAttribute, Mesh } from 'three';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { ConvolutionMaterial } from './ConvolutionMaterial.js';\n\nclass BlurPass {\n  constructor({\n    gl,\n    resolution,\n    width = 500,\n    height = 500\n  }) {\n    _defineProperty(this, \"renderTargetA\", void 0);\n\n    _defineProperty(this, \"renderTargetB\", void 0);\n\n    _defineProperty(this, \"convolutionMaterial\", void 0);\n\n    _defineProperty(this, \"scene\", void 0);\n\n    _defineProperty(this, \"camera\", void 0);\n\n    _defineProperty(this, \"screen\", void 0);\n\n    _defineProperty(this, \"renderToScreen\", false);\n\n    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      stencilBuffer: false,\n      depthBuffer: false,\n      encoding: gl.outputEncoding\n    });\n    this.renderTargetB = this.renderTargetA.clone();\n    this.convolutionMaterial = new ConvolutionMaterial();\n    this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);\n    this.scene = new Scene();\n    this.camera = new Camera();\n    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));\n    this.screen = new Mesh(geometry, this.convolutionMaterial);\n    this.screen.frustumCulled = false;\n    this.scene.add(this.screen);\n  }\n\n  render(renderer, inputBuffer, outputBuffer) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    let material = this.convolutionMaterial;\n    let uniforms = material.uniforms;\n    const kernel = material.kernel;\n    let lastRT = inputBuffer;\n    let destRT;\n    let i, l; // Apply the multi-pass blur.\n\n    for (i = 0, l = kernel.length - 1; i < l; ++i) {\n      // Alternate between targets.\n      destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      uniforms.kernel.value = kernel[i];\n      uniforms.inputBuffer.value = lastRT.texture;\n      renderer.setRenderTarget(destRT);\n      renderer.render(scene, camera);\n      lastRT = destRT;\n    }\n\n    uniforms.kernel.value = kernel[i];\n    uniforms.inputBuffer.value = lastRT.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n\n}\n\nexport { BlurPass };","map":{"version":3,"sources":["/home/julien/Rendu/ETP/React_Front2/node_modules/@react-three/drei/materials/BlurPass.js"],"names":["WebGLRenderTarget","LinearFilter","Scene","Camera","BufferGeometry","BufferAttribute","Mesh","_defineProperty","ConvolutionMaterial","BlurPass","constructor","gl","resolution","width","height","renderTargetA","minFilter","magFilter","stencilBuffer","depthBuffer","encoding","outputEncoding","renderTargetB","clone","convolutionMaterial","setTexelSize","scene","camera","vertices","Float32Array","uvs","geometry","setAttribute","screen","frustumCulled","add","render","renderer","inputBuffer","outputBuffer","material","uniforms","kernel","lastRT","destRT","i","l","length","value","texture","setRenderTarget","renderToScreen"],"mappings":"AAAA,SAASA,iBAAT,EAA4BC,YAA5B,EAA0CC,KAA1C,EAAiDC,MAAjD,EAAyDC,cAAzD,EAAyEC,eAAzE,EAA0FC,IAA1F,QAAsG,OAAtG;AACA,OAAOC,eAAP,MAA4B,2CAA5B;AACA,SAASC,mBAAT,QAAoC,0BAApC;;AAEA,MAAMC,QAAN,CAAe;AACbC,EAAAA,WAAW,CAAC;AACVC,IAAAA,EADU;AAEVC,IAAAA,UAFU;AAGVC,IAAAA,KAAK,GAAG,GAHE;AAIVC,IAAAA,MAAM,GAAG;AAJC,GAAD,EAKR;AACDP,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwB,KAAK,CAA7B,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,eAAP,EAAwB,KAAK,CAA7B,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,qBAAP,EAA8B,KAAK,CAAnC,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,OAAP,EAAgB,KAAK,CAArB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,QAAP,EAAiB,KAAK,CAAtB,CAAf;;AAEAA,IAAAA,eAAe,CAAC,IAAD,EAAO,gBAAP,EAAyB,KAAzB,CAAf;;AAEA,SAAKQ,aAAL,GAAqB,IAAIf,iBAAJ,CAAsBY,UAAtB,EAAkCA,UAAlC,EAA8C;AACjEI,MAAAA,SAAS,EAAEf,YADsD;AAEjEgB,MAAAA,SAAS,EAAEhB,YAFsD;AAGjEiB,MAAAA,aAAa,EAAE,KAHkD;AAIjEC,MAAAA,WAAW,EAAE,KAJoD;AAKjEC,MAAAA,QAAQ,EAAET,EAAE,CAACU;AALoD,KAA9C,CAArB;AAOA,SAAKC,aAAL,GAAqB,KAAKP,aAAL,CAAmBQ,KAAnB,EAArB;AACA,SAAKC,mBAAL,GAA2B,IAAIhB,mBAAJ,EAA3B;AACA,SAAKgB,mBAAL,CAAyBC,YAAzB,CAAsC,MAAMZ,KAA5C,EAAmD,MAAMC,MAAzD;AACA,SAAKY,KAAL,GAAa,IAAIxB,KAAJ,EAAb;AACA,SAAKyB,MAAL,GAAc,IAAIxB,MAAJ,EAAd;AACA,UAAMyB,QAAQ,GAAG,IAAIC,YAAJ,CAAiB,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,EAAS,CAAT,EAAY,CAAZ,EAAe,CAAC,CAAhB,EAAmB,CAAnB,EAAsB,CAAC,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B,CAAjB,CAAjB;AACA,UAAMC,GAAG,GAAG,IAAID,YAAJ,CAAiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,CAAb,EAAgB,CAAhB,CAAjB,CAAZ;AACA,UAAME,QAAQ,GAAG,IAAI3B,cAAJ,EAAjB;AACA2B,IAAAA,QAAQ,CAACC,YAAT,CAAsB,UAAtB,EAAkC,IAAI3B,eAAJ,CAAoBuB,QAApB,EAA8B,CAA9B,CAAlC;AACAG,IAAAA,QAAQ,CAACC,YAAT,CAAsB,IAAtB,EAA4B,IAAI3B,eAAJ,CAAoByB,GAApB,EAAyB,CAAzB,CAA5B;AACA,SAAKG,MAAL,GAAc,IAAI3B,IAAJ,CAASyB,QAAT,EAAmB,KAAKP,mBAAxB,CAAd;AACA,SAAKS,MAAL,CAAYC,aAAZ,GAA4B,KAA5B;AACA,SAAKR,KAAL,CAAWS,GAAX,CAAe,KAAKF,MAApB;AACD;;AAEDG,EAAAA,MAAM,CAACC,QAAD,EAAWC,WAAX,EAAwBC,YAAxB,EAAsC;AAC1C,UAAMb,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMC,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMZ,aAAa,GAAG,KAAKA,aAA3B;AACA,UAAMO,aAAa,GAAG,KAAKA,aAA3B;AACA,QAAIkB,QAAQ,GAAG,KAAKhB,mBAApB;AACA,QAAIiB,QAAQ,GAAGD,QAAQ,CAACC,QAAxB;AACA,UAAMC,MAAM,GAAGF,QAAQ,CAACE,MAAxB;AACA,QAAIC,MAAM,GAAGL,WAAb;AACA,QAAIM,MAAJ;AACA,QAAIC,CAAJ,EAAOC,CAAP,CAV0C,CAUhC;;AAEV,SAAKD,CAAC,GAAG,CAAJ,EAAOC,CAAC,GAAGJ,MAAM,CAACK,MAAP,GAAgB,CAAhC,EAAmCF,CAAC,GAAGC,CAAvC,EAA0C,EAAED,CAA5C,EAA+C;AAC7C;AACAD,MAAAA,MAAM,GAAG,CAACC,CAAC,GAAG,CAAL,MAAY,CAAZ,GAAgB9B,aAAhB,GAAgCO,aAAzC;AACAmB,MAAAA,QAAQ,CAACC,MAAT,CAAgBM,KAAhB,GAAwBN,MAAM,CAACG,CAAD,CAA9B;AACAJ,MAAAA,QAAQ,CAACH,WAAT,CAAqBU,KAArB,GAA6BL,MAAM,CAACM,OAApC;AACAZ,MAAAA,QAAQ,CAACa,eAAT,CAAyBN,MAAzB;AACAP,MAAAA,QAAQ,CAACD,MAAT,CAAgBV,KAAhB,EAAuBC,MAAvB;AACAgB,MAAAA,MAAM,GAAGC,MAAT;AACD;;AAEDH,IAAAA,QAAQ,CAACC,MAAT,CAAgBM,KAAhB,GAAwBN,MAAM,CAACG,CAAD,CAA9B;AACAJ,IAAAA,QAAQ,CAACH,WAAT,CAAqBU,KAArB,GAA6BL,MAAM,CAACM,OAApC;AACAZ,IAAAA,QAAQ,CAACa,eAAT,CAAyB,KAAKC,cAAL,GAAsB,IAAtB,GAA6BZ,YAAtD;AACAF,IAAAA,QAAQ,CAACD,MAAT,CAAgBV,KAAhB,EAAuBC,MAAvB;AACD;;AArEY;;AAyEf,SAASlB,QAAT","sourcesContent":["import { WebGLRenderTarget, LinearFilter, Scene, Camera, BufferGeometry, BufferAttribute, Mesh } from 'three';\nimport _defineProperty from '@babel/runtime/helpers/esm/defineProperty';\nimport { ConvolutionMaterial } from './ConvolutionMaterial.js';\n\nclass BlurPass {\n  constructor({\n    gl,\n    resolution,\n    width = 500,\n    height = 500\n  }) {\n    _defineProperty(this, \"renderTargetA\", void 0);\n\n    _defineProperty(this, \"renderTargetB\", void 0);\n\n    _defineProperty(this, \"convolutionMaterial\", void 0);\n\n    _defineProperty(this, \"scene\", void 0);\n\n    _defineProperty(this, \"camera\", void 0);\n\n    _defineProperty(this, \"screen\", void 0);\n\n    _defineProperty(this, \"renderToScreen\", false);\n\n    this.renderTargetA = new WebGLRenderTarget(resolution, resolution, {\n      minFilter: LinearFilter,\n      magFilter: LinearFilter,\n      stencilBuffer: false,\n      depthBuffer: false,\n      encoding: gl.outputEncoding\n    });\n    this.renderTargetB = this.renderTargetA.clone();\n    this.convolutionMaterial = new ConvolutionMaterial();\n    this.convolutionMaterial.setTexelSize(1.0 / width, 1.0 / height);\n    this.scene = new Scene();\n    this.camera = new Camera();\n    const vertices = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]);\n    const uvs = new Float32Array([0, 0, 2, 0, 0, 2]);\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(vertices, 3));\n    geometry.setAttribute('uv', new BufferAttribute(uvs, 2));\n    this.screen = new Mesh(geometry, this.convolutionMaterial);\n    this.screen.frustumCulled = false;\n    this.scene.add(this.screen);\n  }\n\n  render(renderer, inputBuffer, outputBuffer) {\n    const scene = this.scene;\n    const camera = this.camera;\n    const renderTargetA = this.renderTargetA;\n    const renderTargetB = this.renderTargetB;\n    let material = this.convolutionMaterial;\n    let uniforms = material.uniforms;\n    const kernel = material.kernel;\n    let lastRT = inputBuffer;\n    let destRT;\n    let i, l; // Apply the multi-pass blur.\n\n    for (i = 0, l = kernel.length - 1; i < l; ++i) {\n      // Alternate between targets.\n      destRT = (i & 1) === 0 ? renderTargetA : renderTargetB;\n      uniforms.kernel.value = kernel[i];\n      uniforms.inputBuffer.value = lastRT.texture;\n      renderer.setRenderTarget(destRT);\n      renderer.render(scene, camera);\n      lastRT = destRT;\n    }\n\n    uniforms.kernel.value = kernel[i];\n    uniforms.inputBuffer.value = lastRT.texture;\n    renderer.setRenderTarget(this.renderToScreen ? null : outputBuffer);\n    renderer.render(scene, camera);\n  }\n\n}\n\nexport { BlurPass };\n"]},"metadata":{},"sourceType":"module"}